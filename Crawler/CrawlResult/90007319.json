{
    "id": 90007319,
    "title": "【狂神说Java】JUC并发编程最新版通俗易懂",
    "abstract": "笔记资料交流都在我们的平台：www.kuangstudy.com\n什么是JUC\n线程和进程\nLock锁（重点）\n生产者和消费者问题\n8锁现象\n集合类不安全\nCallable\n常用的辅助类(必会)\n读写锁\n阻塞队列\n线程池(重点)\n四大函数式接口（必需掌握）\nStream流式计算\nForkJoin\n异步回调\nJMM\nVolatile\n彻底玩转单例模式\n深入理解CAS\n原子引用\n各种锁的理解：公平锁、非公平锁、可重入锁、自旋锁、死锁\n\nQQ交流群 : 664386224",
    "authorId": 95256449,
    "uploadTime": 1582048994.0,
    "playCount": 472919,
    "commentCount": 472,
    "bulletCommentCount": 20342,
    "imageUrl": "http://i2.hdslb.com/bfs/archive/d4e7eea4697e51a29d85565cf0d47f187e89231e.jpg",
    "feedback": {
        "like": "1.0万",
        "coin": "1.1万",
        "star": "1.2万",
        "share": "725"
    },
    "comments": [
        "其实老师那段关于if为什么不能用的原因没写明白，我在网上特意去查了查资料，发展我们对wait被唤醒时执行的位置有误解。以下是查到的资料结论：就是用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。这也就是为什么用while而不用if的原因了，因为线程被唤醒后，执行开始的地方是wait之后。",
        "我觉得p7最透彻的简答应该是这样的。拿两个加法线程A、B来说，比如A先执行，执行时调用了wait方法，那它会等待，此时会释放锁，那么线程B获得锁并且也会执行wait方法，两个加线程一起等待被唤醒。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后B再执行。如果是if的话，那么A修改完num后，B不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，B还会去判断num的值，因此就不会执行。",
        "面试手写：\t单例模式，\t排序算法\t生产者和消费者\t死锁",
        "B站最好的 JUC 老师，B站最好的理财老师。 你三连有了",
        "这个虚假唤醒我说一下我的通俗理解哈if（）{this.wait();}如果用if，那么wait之后线程的指针是停留在大括号}这的，这时候该线程被唤醒，接着往后执行number++或--而如果用whilewhile() {this.wait();}此时wait执行后，线程的指针还是指向大括号}但是while的性质是一直判断，所以该线程被唤醒后还会再一次判断while括号内的条件以上是困了我半小时后的理解，希望能帮助到大家"
    ],
    "tags": [
        "程序员",
        "公开课",
        "科技",
        "计算机技术",
        "JUC教程",
        "Java学习",
        "JUC",
        "狂神说Java",
        "多线程",
        "Java",
        "JavaSE",
        "JavaEE"
    ]
}